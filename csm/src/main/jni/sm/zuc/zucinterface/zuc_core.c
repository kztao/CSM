
#include <memory.h>
#include "zuc_core.h"


#define MIN(x,y)	((x) >  (y)  ? (y)  : (x))

/* ----------------------- */ 
/* c = a + b mod 2exp(31) - 1 */
#define ADD_MOD(c, a){\
	c += a;\
	if (c & 0x80000000){\
		c = (c & 0x7FFFFFFF) + 1;\
	}\
}

/* LFSR with initialization mode */
#define MulByPow2(x, k) ((((x) << k) | ((x) >> (31 - k))) & 0x7FFFFFFF)
//#define MulByPow2(x, k) (((x) << k) | ((x) >> (31 - k)))

/* r += x pow{k} mod 2^31 - 1 */
#define ADD_POW2(r, x, k){\
	r += ((((x) << k) | ((x) >> (31 - k))) & 0x7FFFFFFF);\
	if (r & 0x80000000){\
		r = (r & 0x7FFFFFFF) + 1;\
	}\
}

/* zuc init use: s = k_8b || d_15b || iv_8b */
#define MAKE_U31(a, b, c)\
	(((mm_u32_t)(a) << 23) | ((mm_u32_t)(b) << 8) | (mm_u32_t)(c))

/* a <<< num */
#if defined(_MSC_VER) 
#include <stdlib.h>
#define ROT(a,num)	_lrotl(a,num)
#endif

#ifndef ROT
#define ROT(a, num) (((a) << num) | ((a) >> (32 - num)))
#endif

/* L1 */
#define L1_FUNC(X) (X ^ ROT(X, 2) ^ ROT(X, 10) ^ ROT(X, 18) ^ ROT(X, 24)) 

/* L2 */
#define L2_FUNC(X) (X ^ ROT(X, 8) ^ ROT(X, 14) ^ ROT(X, 22) ^ ROT(X, 30))
 
/* S */ 
#define S_FUNC(x) \
	( ((mm_u32_t)(S0[((x)>>24)     ])<<24)\
	| ((mm_u32_t)(S1[((x)>>16)&0xFF])<<16)\
	| ((mm_u32_t)(S0[((x)>> 8)&0xFF])<< 8)\
	| ((mm_u32_t)(S1[((x)    )&0xFF])    ) ) 

/* BitReorganization */
#define CONNECT(left, right) ( ( (left) << 16 ) | ( (right)  >> 15 ) )
#define GET_X0(L14,L15)	((((L15) & 0x7FFF8000) <<  1) | ((L14) &  0xFFFF))
#define GET_X1(L9, L11)	CONNECT(L11, L9)
#define GET_X2(L5, L7)	CONNECT(L7, L5)
#define GET_X3(L0, L2)	CONNECT(L2, L0)

/* the s-boxes */  
mm_u8_t S0[256] = {
	0x3e,0x72,0x5b,0x47,0xca,0xe0,0x00,0x33,0x04,0xd1,0x54,0x98,0x09,0xb9,0x6d,0xcb, 
	0x7b,0x1b,0xf9,0x32,0xaf,0x9d,0x6a,0xa5,0xb8,0x2d,0xfc,0x1d,0x08,0x53,0x03,0x90, 
	0x4d,0x4e,0x84,0x99,0xe4,0xce,0xd9,0x91,0xdd,0xb6,0x85,0x48,0x8b,0x29,0x6e,0xac, 
	0xcd,0xc1,0xf8,0x1e,0x73,0x43,0x69,0xc6,0xb5,0xbd,0xfd,0x39,0x63,0x20,0xd4,0x38, 
	0x76,0x7d,0xb2,0xa7,0xcf,0xed,0x57,0xc5,0xf3,0x2c,0xbb,0x14,0x21,0x06,0x55,0x9b, 
	0xe3,0xef,0x5e,0x31,0x4f,0x7f,0x5a,0xa4,0x0d,0x82,0x51,0x49,0x5f,0xba,0x58,0x1c, 
	0x4a,0x16,0xd5,0x17,0xa8,0x92,0x24,0x1f,0x8c,0xff,0xd8,0xae,0x2e,0x01,0xd3,0xad, 
	0x3b,0x4b,0xda,0x46,0xeb,0xc9,0xde,0x9a,0x8f,0x87,0xd7,0x3a,0x80,0x6f,0x2f,0xc8, 
	0xb1,0xb4,0x37,0xf7,0x0a,0x22,0x13,0x28,0x7c,0xcc,0x3c,0x89,0xc7,0xc3,0x96,0x56, 
	0x07,0xbf,0x7e,0xf0,0x0b,0x2b,0x97,0x52,0x35,0x41,0x79,0x61,0xa6,0x4c,0x10,0xfe, 
	0xbc,0x26,0x95,0x88,0x8a,0xb0,0xa3,0xfb,0xc0,0x18,0x94,0xf2,0xe1,0xe5,0xe9,0x5d, 
	0xd0,0xdc,0x11,0x66,0x64,0x5c,0xec,0x59,0x42,0x75,0x12,0xf5,0x74,0x9c,0xaa,0x23, 
	0x0e,0x86,0xab,0xbe,0x2a,0x02,0xe7,0x67,0xe6,0x44,0xa2,0x6c,0xc2,0x93,0x9f,0xf1, 
	0xf6,0xfa,0x36,0xd2,0x50,0x68,0x9e,0x62,0x71,0x15,0x3d,0xd6,0x40,0xc4,0xe2,0x0f, 
	0x8e,0x83,0x77,0x6b,0x25,0x05,0x3f,0x0c,0x30,0xea,0x70,0xb7,0xa1,0xe8,0xa9,0x65, 
	0x8d,0x27,0x1a,0xdb,0x81,0xb3,0xa0,0xf4,0x45,0x7a,0x19,0xdf,0xee,0x78,0x34,0x60
}; 

mm_u8_t S1[256] =  {
	0x55,0xc2,0x63,0x71,0x3b,0xc8,0x47,0x86,0x9f,0x3c,0xda,0x5b,0x29,0xaa,0xfd,0x77, 
	0x8c,0xc5,0x94,0x0c,0xa6,0x1a,0x13,0x00,0xe3,0xa8,0x16,0x72,0x40,0xf9,0xf8,0x42,
	0x44,0x26,0x68,0x96,0x81,0xd9,0x45,0x3e,0x10,0x76,0xc6,0xa7,0x8b,0x39,0x43,0xe1,
	0x3a,0xb5,0x56,0x2a,0xc0,0x6d,0xb3,0x05,0x22,0x66,0xbf,0xdc,0x0b,0xfa,0x62,0x48, 
	0xdd,0x20,0x11,0x06,0x36,0xc9,0xc1,0xcf,0xf6,0x27,0x52,0xbb,0x69,0xf5,0xd4,0x87, 
	0x7f,0x84,0x4c,0xd2,0x9c,0x57,0xa4,0xbc,0x4f,0x9a,0xdf,0xfe,0xd6,0x8d,0x7a,0xeb, 
	0x2b,0x53,0xd8,0x5c,0xa1,0x14,0x17,0xfb,0x23,0xd5,0x7d,0x30,0x67,0x73,0x08,0x09, 
	0xee,0xb7,0x70,0x3f,0x61,0xb2,0x19,0x8e,0x4e,0xe5,0x4b,0x93,0x8f,0x5d,0xdb,0xa9, 
	0xad,0xf1,0xae,0x2e,0xcb,0x0d,0xfc,0xf4,0x2d,0x46,0x6e,0x1d,0x97,0xe8,0xd1,0xe9, 
	0x4d,0x37,0xa5,0x75,0x5e,0x83,0x9e,0xab,0x82,0x9d,0xb9,0x1c,0xe0,0xcd,0x49,0x89, 
	0x01,0xb6,0xbd,0x58,0x24,0xa2,0x5f,0x38,0x78,0x99,0x15,0x90,0x50,0xb8,0x95,0xe4, 
	0xd0,0x91,0xc7,0xce,0xed,0x0f,0xb4,0x6f,0xa0,0xcc,0xf0,0x02,0x4a,0x79,0xc3,0xde, 
	0xa3,0xef,0xea,0x51,0xe6,0x6b,0x18,0xec,0x1b,0x2c,0x80,0xf7,0x74,0xe7,0xff,0x21, 
	0x5a,0x6a,0x54,0x1e,0x41,0x31,0x92,0x35,0xc4,0x33,0x07,0x0a,0xba,0x7e,0x0e,0x34, 
	0x88,0xb1,0x98,0x7c,0xf3,0x3d,0x60,0x6c,0x7b,0xca,0xd3,0x1f,0x32,0x65,0x04,0x28, 
	0x64,0xbe,0x85,0x9b,0x2f,0x59,0x8a,0xd7,0xb0,0x25,0xac,0xaf,0x12,0x03,0xe2,0xf2 
}; 

void zuc_mem_mov( mm_u8_t * dst, const mm_u8_t * src, mm_u32_t count )
{
	while (count--) 
	{
		*dst++ = *src++;
	}
}

/* initialize */
mm_i32_t zuc_init_core(zuc_ctx *p, mm_u8_t key[ZUC_KEY_LEN], 
					   mm_u8_t iv[ZUC_IV_LEN])
{
	const mm_u32_t d_cst[16] = /* the constants D */
	{	
		0x44D7, 0x26BC, 0x626B, 0x135E, 0x5789, 0x35E2, 0x7135, 0x09AF,
		0x4D78, 0x2F13, 0x6BC4, 0x1AF1, 0x5E26, 0x3C4D, 0x789A, 0x47AC
	}; 
	mm_u32_t w, count, *p_lfsr = &p->lfsr_0;
	mm_i32_t i;
	
	memset(p, 0x00, sizeof(zuc_ctx));
	
	/* expand key */
	for (i = 0; i < 16; i++ )
	{
		p_lfsr[i] = MAKE_U31( key[i], d_cst[i], iv[ i] );
	} 
	
	/* set F_R1 and F_R2 to zero */
	/*p->t1 = p->t2 = 0;*/
	
	count = 32;
	while (count-- > 0)
	{ 
		zuc_one_step(p, &w); 
		ADD_MOD(p->lfsr_15, w>>1); 
	} 
	
	zuc_one_step(p, &w); 
	
	p_lfsr = NULL;
	
	return 1;
}


/* uninitialize */
mm_i32_t zuc_unit_core(zuc_ctx *p )
{
	memset(p, 0x00, sizeof(zuc_ctx));
	return 1;
}


/* one step, generate 32bit key */
mm_u32_t zuc_one_step(zuc_ctx *p,  mm_u32_t *p_w)
{
	register mm_u32_t t1, t2, w, w1, w2;
  
	/* F函数	比特重组混合到F函数的实现中 */  
	/* where t1 = p->r1; t2 = p->r2; */
	t1 = p->r1;
	t2 = p->r2;
	w =  t2 + ( t1 ^ GET_X0(p->lfsr_14, p->lfsr_15)  );
	w1 = t1 + GET_X1(p->lfsr_9, p->lfsr_11);
	w2 = t2 ^ GET_X2(p->lfsr_5, p->lfsr_7 );

	/* where t1 || t2 = (w1||w2) <<< 16;  r1 = S(L1(t1));	r2 = S(L2(t2));  */
	t1 = (w1 << 16) | (w2 >> 16);
	t2 = (w2 << 16) | (w1 >> 16);
	t1 = L1_FUNC(t1);
	t2 = L2_FUNC(t2); 
	p->r1 = S_FUNC(t1);
	p->r2 = S_FUNC(t2); 
 
	if( p_w )	/* get output key w */
	{
		*p_w = w;
	}
	w ^= GET_X2(p->lfsr_0, p->lfsr_2 );

	/* where t2 = L*;  t1 = ( 2exp(15)*L15 ) + ...  mode ( 2exp(31) - 1 ) */
	t1 = t2 = p->lfsr_0;
	ADD_POW2(t1, t2, 8);
	t2 = p->lfsr_4; 
	ADD_POW2(t1, t2, 20);
	t2 = p->lfsr_10;
	ADD_POW2(t1, t2, 21); 
	t2 = p->lfsr_13;
	ADD_POW2(t1, t2, 17); 
	t2 = p->lfsr_15;
	ADD_POW2(t1, t2, 15); 

	if ( !t1 )/* adjust LFSR_S15 if LFSR_S15 is zero */
	{ 
		t1 = 0x7FFFFFFF;
	}

	/* update the state */ 
//	MM_MEMCPY(&p->lfsr_0, &p->lfsr_1, 15*sizeof(mm_u32_t)); /* slow */
	p->lfsr_0  = p->lfsr_1;  p->lfsr_1  = p->lfsr_2;  p->lfsr_2  = p->lfsr_3; 
	p->lfsr_3  = p->lfsr_4;  p->lfsr_4  = p->lfsr_5;  p->lfsr_5  = p->lfsr_6; 
	p->lfsr_6  = p->lfsr_7;  p->lfsr_7  = p->lfsr_8;  p->lfsr_8  = p->lfsr_9; 
	p->lfsr_9  = p->lfsr_10; p->lfsr_10 = p->lfsr_11; p->lfsr_11 = p->lfsr_12;
	p->lfsr_12 = p->lfsr_13; p->lfsr_13 = p->lfsr_14; p->lfsr_14 = p->lfsr_15; 
	p->lfsr_15 = t1; 

	return w;
} 
 
#if 0/** luoying 20160613 旧的代码，逻辑上存在一些问题，导致多次调用时异常 **/
mm_i32_t zuc_enc_dec_core_old(zuc_ctx *p, mm_u8_t *p_in, mm_u32_t bit_len, 
						  mm_u8_t *p_out )
{ 
	mm_u8_t  key_byte[4]; 
	mm_u32_t i, tmp_len, key_u32;
	mm_u32_t byte_len = (bit_len+7)/8; 

	/*
	1. 当整个执行过程中只需调用本函数一次时
		bit_len 可以不是 8 的倍数，即数据可以是不完整的字节。
	2. 当需要反复调用本函数时，
		第一次至倒数第二次调用时，bit_len需是8的倍数，即数据是完整的字节
		最后一次的 bit_len 可以不是 8 的倍数，即数据可以是不完整的字节。
	3. 如果不满足以上说明，将报错-2。
	*/
	if( p->deal_bit )
	{
		return -2;
	}
	/* generating keystream of ZUC */  
	
	/* 1. 用上一次缓存的key加密数据 */
	tmp_len = p->left_byte;
	if ( tmp_len )
	{
		for ( i = 0; i < tmp_len; i++ )
		{
			p_out[i] = p_in[i] ^ p->key[i];
		}
		
		byte_len-= tmp_len;
		p_in	+= tmp_len;
		p_out	+= tmp_len; 
	}
	p->left_byte = 0;
	
	/* 2. 生成key来加密数据 */
	while( byte_len >= ZUC_KEY_STREAM_SIZE )
	{ 
		zuc_gen_key_u32(p, key_u32);
		MM_STORE_U32H(key_u32, key_byte ); 

		for ( i = 0; i < ZUC_KEY_STREAM_SIZE; i++ )
		{
			p_out[i] = p_in[i] ^ key_byte[i];
		}
		
		byte_len-= ZUC_KEY_STREAM_SIZE;
		p_in	+= ZUC_KEY_STREAM_SIZE;
		p_out	+= ZUC_KEY_STREAM_SIZE;
	}
	
	/* 3. 最后一次的消息长度可能不足32比特，则部分用于加密数据，部分保存下来 */
	if( byte_len )
	{
		zuc_gen_key_u32(p, key_u32);
		MM_STORE_U32H(key_u32, key_byte ); 
		
		for ( i = 0; i < byte_len; i++ )
		{
			*p_out++ = *p_in++ ^ key_byte[i];
		}
		p->left_byte = ZUC_KEY_STREAM_SIZE - byte_len;
		memcpy(p->key, key_byte + i, p->left_byte); 
	} 

	tmp_len = bit_len & 0x7; /* 不能组成字节的比特个数 */ 
	if (tmp_len)
	{
		p_out[-1] ^= key_byte[i-1] & (0xff>>tmp_len);/* 消去异或上去的密钥比特*/
		p->deal_bit = 1;
	} 

	/* clear */ 
	key_u32 = 0;
	memset(key_byte, 0x00, sizeof(key_byte));
	
	return 1;
}
#endif

/*
	1. 当整个执行过程中只需调用本函数一次时
		bit_len 可以不是 8 的倍数，即数据可以是不完整的字节。
	2. 当需要反复调用本函数时，
		第一次至倒数第二次调用时，bit_len需是8的倍数，即数据是完整的字节
		最后一次的 bit_len 可以不是 8 的倍数，即数据可以是不完整的字节。
	3. 如果不满足以上说明，将报错-2。
*
* luoying 20160613 新的zuc_enc_dec_core代码，修正多次调用异常的问题
**/
mm_i32_t zuc_enc_dec_core(zuc_ctx *p, mm_u8_t *p_in, mm_u32_t bit_len, mm_u8_t *p_out )
{ 
	mm_u32_t i = 0, xor_len = 0;
	mm_u32_t byte_len = (bit_len+7)/8; /** 输入数据的字节长度（向上取整） **/
	mm_u8_t  *p_key_byte = p->key;
	mm_u8_t  last_key = 0; 

	if( p->deal_bit )
	{
		return -2;
	}
	if( bit_len == 0 )
	{
		return 1;/** 长度为零则不处理 **/
	}

	/* 1. 用上一次缓存的key加密数据 */ 
	xor_len = MIN(p->left_byte, byte_len);//min
	if( xor_len )
	{
		for ( i = 0; i < xor_len; i++ )
		{
			p_out[i] = p_in[i] ^ p_key_byte[i];
		}

		p->left_byte-= xor_len;	
		byte_len	-= xor_len;
		p_in		+= xor_len;
		p_out		+= xor_len; 
		last_key = p_key_byte[xor_len-1];/** 备份KEY缓存区的最后一个字节 **/
		zuc_mem_mov(p_key_byte, p_key_byte + xor_len, p->left_byte);/** 保存多余的KEY **/
	}

	/* 2. 生成key来加密数据 */ 
	if( byte_len > 0 )
	{
		while( byte_len > 0 )
		{ 
			zuc_gen_key_u32(p, i);	// i <= zuc gen key u32
			MM_STORE_U32H(i, p_key_byte ); 

			xor_len = MIN(ZUC_KEY_STREAM_SIZE, byte_len);//min
			for ( i = 0; i < xor_len; i++ )
			{
				p_out[i] = p_in[i] ^ p_key_byte[i];
			}

			byte_len-= xor_len;
			p_in	+= xor_len;
			p_out	+= xor_len;
			last_key = p_key_byte[xor_len-1];/** 备份生成KEY的最后一个字节 **/
		}

		p->left_byte = ZUC_KEY_STREAM_SIZE - xor_len;
		zuc_mem_mov(p_key_byte, p_key_byte + xor_len, p->left_byte); 
	}

	/* 3. 不能组成字节的比特处理 */ 
	i = bit_len & 0x7; // i <= res bit len
	if (i)
	{
		p_out[-1] ^= last_key & (0xff>>i);/* 消去异或上去的密钥比特*/
		p->deal_bit = 1;/** 设置处理比特标识 **/
	} 
	
	return 1;
}
